
# Clean Architecture
우리가 가장 관심 있는 길은 바로 가장 깔끔한(Clena) 길이다. 이 길은 소프트웨어가 지닌 ‘부드러움(Softness)’을 인지하고, 이 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다.

---
## [서문]
- 1960년대나 1950년대와 마찬가지로 코드는 여전히 Sequence(순차), Selection(분기), Iteration(반복)의 집합체일 뿐이다.
- 소프트웨어 아키텍처의 규칙이란, 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다. 
- 이 책은 바로 이 규칙, 세월이 흘러도 변치 않는 그 규칙에 관한 것이다.

---
## [설계와 아키텍처란?]
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.
- 어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

---
## [소프트웨어의 가치]
모든 소프트웨어 시스템은 이해관계자에게 다음의 서로 다른 두 가지 가치를 제공한다.  

1. 행위 (Behavior)    
2. 구조 (Structure)


### 행위
- 프로그래머는 이해관계자(고용인 또는 기업)를 위해 기계가 수익을 창출하거나 비용을 절약하도록 코드를 작성한다.
- 이를 위해 프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다.
- 기계가 이러한 요구사항을 위반하면, 프로그래머는 디버거를 열고 문제를 진단하여 수정한다.

### 아키텍처
- '소프트웨어'라는 단어는 '부드러운'과 '제품'이라는 단어의 합성어다. 소프트웨어는 '부드러움을 지니도록' 만들어졌다.
- 소프트웨어가 가진 본연의 목적을 추구하려면, 변경하기 쉬워야 한다.

아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## [프로그래밍 패러다임]
소프트웨어 아키텍처는 코드(code)로부터 시작한다.  
패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다. 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

### 1. 구조적 프로그래밍
- 뵘, 야코피니는 모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration)이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다. (구조적 프로그래밍의 탄생)
    
- 1968년 데이크스트라는 프로그래밍의 세 가지 제어 구조에 대해 강력히 주장했다.
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.

    “테스트”
    테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다. -데이크스트라-
    
- 테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.
    
- 오히려 소프트웨어는 과학과 같다. 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 스프트웨어 개발은 수학적인 시도가 아니라는 사실이다.
최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써, 올바름을 보여주기 때문이다.
구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.
가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.
    
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
    
### 2. 객체 지향 프로그래밍
- 좋은 아키텍처를 만드는 일은 객체 지향(Object Oriented) 설계 원칙을 이해하고 응용하는 데서 출발한다.
- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면, 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
    
### 3. 함수형 프로그래밍
TODO
    
---
## [설계 원칙]
좋은 소프트웨어 시스템은 깔끔한 코드(Clean code)로부터 나온다. 
좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게 바로 SOLID다.

### 1. SRP: 단일 책임 원칙 (Single Responsibility Principle)
- 하나의 모듈을 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 여기서 ‘모듈'이란 단어의 가장 단순한 정의는 ‘소스 파일' 이다.
    
### 2. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 아키텍트는 기능이 어떻게(how), 왜(why), 언제(whe) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
    
### 3. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)
- 상호 대체(치환) 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
- 치환 원칙은 다음과 같다.
    - S 타입의 객체 o1 각각에 대응하는 T 타입의 객체 o2가 있다. T 타입을 이용해서 정의한 모든 함수, 프로그램 func A 에서 o2의 자리에 o1을 갈아 끼우더라더도 func A의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘(예외 처리)을 추가해야 할 수 있기 때문에 아키텍처 설계 시 주의를 기울여야 한다.
    
### 4. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
- ISP는 언어 종료에 따라 영향받는 정도가 다르다.
- 일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.

### 5. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)
- ‘유연성이 극대화된 시스템’이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.
- 안정된 소프트웨어 아키텍처란, 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.  
    - 변동성이 큰 구체 클래스를 참조하지 말라.
    - 변동성이 큰 구체 클래스로부터 파생하지 말라.
    - 구체 함수를 오버라이드 하지 말라.
- 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자. 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전 이라고 부른다.

---
## [컴포넌트]
TODO